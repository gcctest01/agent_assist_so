const express = require("express");
const axios = require("axios");
const { IamAuthenticator } = require("ibm-watson/auth");
const NaturalLanguageUnderstandingV1 = require("ibm-watson/natural-language-understanding/v1");
require("dotenv").config();

const app = express();
app.use(express.json());

// ---------------- MIDDLEWARE CORS ----------------
app.use((req, res, next) => {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With, Origin, Accept");
  res.setHeader("Access-Control-Allow-Credentials", "false");
  res.setHeader("Access-Control-Max-Age", "7200");
  next();
});

// ---------------- TOKEN IAM ----------------
let cachedToken = null;
let tokenExpiry = 0;

async function getIamToken() {
  const now = Date.now() / 1000;
  if (cachedToken && now < tokenExpiry - 60) return cachedToken;

  const res = await axios.post(
    "https://iam.platform.saas.ibm.com/siusermgr/api/1.0/apikeys/token",
    { apikey: process.env.WXO_API_KEY },
    { headers: { "Content-Type": "application/json" } }
  );

  cachedToken = res.data.token;
  tokenExpiry = now + res.data.expires_in;
  return cachedToken;
}

// ---------------- CONFIGURATION WATSON NLU ----------------
const nlu = new NaturalLanguageUnderstandingV1({
  version: '2021-08-01',
  authenticator: new IamAuthenticator({ apikey: process.env.WATSON_NLU_API_KEY }),
  serviceUrl: process.env.WATSON_NLU_URL,
});

// ---------------- THREADS ----------------
const threads = {}; // threads[clientId] = { messages: [], threadId: "" }

// ---------------- ANALYSE DU SENTIMENT ----------------
async function analyzeSentiment(message) {
  try {
    if (!message || message.trim().length === 0) return 0;
    const analyzeParams = { text: message, features: { sentiment: {} } };
    const analysis = await nlu.analyze(analyzeParams);
    return analysis.result.sentiment.document.score || 0;
  } catch (err) {
    console.warn("NLU failed, sentiment neutralized:", err.message);
    return 0;
  }
}

// ---------------- ENDPOINT ORCHESTRATE ----------------
app.post("/api/sendToOrchestrate", async (req, res) => {
  try {
    const { message, clientId, sentimentEnabled } = req.body;
    if (!message || !clientId) return res.status(400).json({ error: "Message ou clientId manquant" });

    const token = await getIamToken();
    if (!threads[clientId]) threads[clientId] = { messages: [], threadId: null };

    threads[clientId].messages.push({ role: "user", content: message });

    let sentimentScore = 0;
    if (sentimentEnabled) sentimentScore = await analyzeSentiment(message);

    const url = `${process.env.WXO_API_ENDPOINT}/v1/orchestrate/${process.env.WXO_AGENT_ID}/chat/completions`;
    const headers = { Authorization: `Bearer ${token}`, "Content-Type": "application/json" };
    if (threads[clientId].threadId) headers["X-IBM-THREAD-ID"] = threads[clientId].threadId;

    const response = await axios.post(url, { stream: false, messages: threads[clientId].messages }, { headers });

    const botResponse = response.data.choices?.[0]?.message?.content || "Pas de rÃ©ponse du bot.";
    if (response.data.thread_id) threads[clientId].threadId = response.data.thread_id;

    threads[clientId].messages.push({ role: "assistant", content: botResponse });

    res.json({ reply: botResponse, sentiment: sentimentScore });

  } catch (error) {
    console.error("Erreur API Orchestrate:", error.response?.data || error.message);
    res.status(500).json({ error: "Erreur API Orchestrate" });
  }
});

// ---------------- ENDPOINT SUMMARIZE ----------------
app.post("/api/summarize", async (req, res) => {
  try {
    const { clientId } = req.body;
    if (!clientId || !threads[clientId] || threads[clientId].messages.length === 0) {
      return res.status(400).json({ summary: "Aucune conversation trouvÃ©e pour ce client." });
    }

    const token = await getIamToken();
    const url = `${process.env.WXO_API_ENDPOINT}/v1/orchestrate/${process.env.WXO_AGENT_SUM_ID}/chat/completions`;

    const conversationText = threads[clientId].messages.map(m => `${m.role.toUpperCase()} :\n${m.content}`).join("\n\n");

    const headers = { Authorization: `Bearer ${token}`, "Content-Type": "application/json" };
    const response = await axios.post(url, { stream: false, messages: [{ role: "user", content: conversationText }] }, { headers });

    const summary = response.data.choices?.[0]?.message?.content || "Impossible de gÃ©nÃ©rer le rÃ©sumÃ©.";
    res.json({ summary });

  } catch (err) {
    console.error("Erreur summarize:", err.response?.data || err.message);
    res.status(500).json({ summary: "Erreur lors de la gÃ©nÃ©ration du rÃ©sumÃ©." });
  }
});

// ---------------- HEALTH ----------------
app.get("/api/health", (req, res) => res.json({ status: "ok" }));

// ---------------- SERVER START ----------------
const PORT = process.env.PORT || 3000;
app.listen(PORT, "0.0.0.0", () => {
  console.log(`ðŸš€ Serveur dÃ©marrÃ© sur le port ${PORT}`);
});
